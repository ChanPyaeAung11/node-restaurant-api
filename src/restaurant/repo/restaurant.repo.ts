import { createOrderType } from "../../app";
import {
  customers,
  customersSelect,
  db,
  employees,
  employeesSelect,
  menu,
  menuSelect,
  orderItems,
  orders,
  ordersSelect,
  restaurants,
  restaurantsSelect,
  orderItemsSelect,
} from "../../data";
import { eq, inArray, sql } from "drizzle-orm";

class RestaurantRepo {
  async getCustomers(): Promise<customersSelect[]> {
    return await db.select().from(customers);
  }

  async getEmployees(): Promise<employeesSelect[]> {
    return await db.select().from(employees);
  }

  async getMenu(): Promise<menuSelect[]> {
    return await db.select().from(menu);
  }

  async getRestaurants(): Promise<restaurantsSelect[]> {
    return await db.select().from(restaurants);
  }

  async getOrdersFromAllCustomers(
    limit: number,
    offset: number
  ): Promise<customerOrders[]> {
    return await db
      .select({ customerName: customers.name, menuName: menu.name })
      .from(customers)
      .innerJoin(orders, eq(customers.id, orders.customerId))
      .innerJoin(orderItems, eq(orders.id, orderItems.orderId))
      .innerJoin(menu, eq(menu.id, orderItems.itemId))
      .orderBy(customers.name)
      .limit(limit)
      .offset(offset)
      .execute();
  }

  async getOrdersFromCustomer(customerId: number) {
    if ((await this.getCustomerById(customerId)).length !== 0) {
      return await db
        .select({ menuName: menu.name })
        .from(customers)
        .innerJoin(orders, eq(customers.id, orders.customerId))
        .innerJoin(orderItems, eq(orders.id, orderItems.orderId))
        .innerJoin(menu, eq(menu.id, orderItems.itemId))
        .where(eq(customers.id, customerId))
        .execute();
    } else {
      return 0;
    }
  }

  async getCustomerById(customerId: number): Promise<customersSelect[]> {
    const result: customersSelect[] = await db
      .select()
      .from(customers)
      .where(eq(customers.id, customerId));
    return result;
  }

  async restaurantExists(restaurantId: number): Promise<boolean> {
    let restaurantExists: restaurantsSelect[];

    restaurantExists = await db
      .select()
      .from(restaurants)
      .where(eq(restaurants.id, restaurantId));

    return restaurantExists.length > 0 ? true : false;
  }

  async createRestaurant(
    restaurant: restaurantsSelect
  ): Promise<restaurantsSelect[] | number> {
    // checking if restaurantName alrdy exists make it idempotent
    const restaurantExists: restaurantsSelect[] = await db
      .select()
      .from(restaurants)
      .where(eq(restaurants.name, restaurant.name));

    if (restaurantExists.length === 0)
      // this code is responsible for making sure if id is not included, it will ask postgres to autogenerated or put in manual id
      return await db.insert(restaurants).values(restaurant).returning();
    // to indicate if restaurant alrdy exists to a user
    return 0;
  }

  async createNewEmployee(newEmployee: employeesSelect, restaurantId: number) {
    // to make this idempotent, need more data fields to distinct users with same name, dob
    return (await this.restaurantExists(restaurantId))
      ? await db.insert(employees).values(newEmployee).returning()
      : null;
  }

  async createNewOrder(inboundOrder: createOrderType) {
    let restaurantId = inboundOrder.restaurantId;

    if (await this.restaurantExists(restaurantId)) {
      console.log("Restaurant exists ", restaurantId);
    } else {
      console.log("Restaurant does not exist");
      return "Restaurant does not exist";
    }

    const orderItemList: number[] = inboundOrder.itemIds;
    const orderList = await db
      .select()
      .from(menu)
      .where(inArray(menu.id, orderItemList));
    if (orderList.length !== orderItemList.length) {
      return "Some items here do not exist";
    }

    const customerName = inboundOrder.customerName;
    let customer: customersSelect[];

    await db.transaction(
      async (tx) => {
        // table only has id and name, to make users more distinct, put sth like dob
        // currently, customers with same name will use the same customerId
        customer = await tx
          .select()
          .from(customers)
          .where(eq(customers.name, customerName));

        // insert new customer
        if (customer.length === 0) {
          customer = await tx
            .insert(customers)
            .values({ name: customerName })
            .returning();
        }
        const customerId = customer[0].id;
        console.log("customer id", customerId);

        // insert into orders table
        let orderInsert: ordersSelect[];
        orderInsert = await tx
          .insert(orders)
          .values({ customerId, restaurantId })
          .returning();
        const insertedOrderId = orderInsert[0].id;

        // insert into order_items table

        for (let item of orderItemList) {
          const orderItemInserted = await tx
            .insert(orderItems)
            .values({ orderId: insertedOrderId, itemId: item })
            .returning();
          console.log(orderItemInserted);
        }
      },
      {
        isolationLevel: "serializable",
        accessMode: "read write",
        deferrable: false,
      }
    );
    console.log("Transaction commited successfully");
    return 1;
  }

  async createCustomer(name: string) {
    return await db.insert(customers).values({ name }).returning();
  }
  async updateRestaurant(
    updateRestaurant: restaurantsSelect,
    id: number
  ): Promise<restaurantsSelect[]> {
    return await db
      .update(restaurants)
      .set({ name: updateRestaurant.name, sales: updateRestaurant.sales })
      .where(eq(restaurants.id, id))
      //.where(sql`${restaurants.id}=${id}`) // this is only partial parameterized
      .returning();
  }

  async deleteRestaurant(id: number): Promise<restaurantsSelect[]> {
    return await db
      .delete(restaurants)
      .where(eq(restaurants.id, id))
      .returning();
  }
}
// when typing or interfacing, need to put in exact keyName returned by query
export interface customerOrders {
  customerName: string;
  menuName: string;
}

const restaurantRepo = new RestaurantRepo();
export default restaurantRepo;
